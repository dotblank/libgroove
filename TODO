- cache GrooveRequest to not hit up grooveshark where possible (e.g. searches)
  -> we can also extend this to *somewhat* work offline maybe?
- Change GrooveSong::streamingStarted() signal to pass the GrooveSong that is
  streaming?
- Unit testing for GrooveSearchModel
- Unit testing for GrooveSongsModel
- Integrate radio mode into GroovePlaylistMode:
  GPM::setRadioMode(true);
  ::next() automatically initiates a radio request for next track if there are 1 (or 2?) tracks remaining
- Integrate API for prefetch mode into GrooveSong somehow (startStreaming()
  plus a new startPrefetch()?) - seems clumsy; perhaps playlistmodel could
  handle prefetch somehow? that way the request from the client would use the
  cached track
- Review types of data in GrooveSong
- API documentation, GrooveSong and everywhere
- GroovePlaylistModel::setCurrentTrack(int)? const QModelIndex&?
  not QModelIndex, otherwise using from QML is impossible, sigh

- Error handling
  GrooveRequest makes this a lot easier, but we still need to make sure we
  handle this everywhere:
  - On connection
  - On search request
  - On stream key request
  - Let client handle streaming errors
    (but make sure GrooveStream exposes them!)
  - "invalid token" error
    we can handle this inside GrooveRequest directly, by checking for it after
    parsing JSON, restarting the connection procecss, and resubmitting requests
    after a successful connection
